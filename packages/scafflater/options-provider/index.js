const path = require('path')
const fsUtil = require('../fs-util')
const { RegionProvider } = require('../generator/region-provider')

/**
 * @typedef {object} Config
 * @description The generation configuration
 */
class OptionsProvider {

  constructor() {
    this.lineCommentTemplate = '# {{{comment}}}'
    this.startRegionMarker = '@scf-region'
    this.endRegionMarker = '@end-scf-region'
    this.optionMarker = '@scf-option'
    // Can be handlebars
    this.targetName = null
    this.ignore = false
    this.annotate = false
    this.annotationTemplate = `{{#lineComment this}}{{{config.startRegionMarker}}}{{/lineComment}}
{{#lineComment this}}This code was generated by scafflater{{/lineComment}}
{{#lineComment this}}@template {{{template.name}}} (v{{{template.version}}}){{/lineComment}}
{{#lineComment this}}@partial {{{partial.name}}}{{/lineComment}}
{{#each parameters }}
{{#lineComment this}}@{{{@key}}} {{{this}}}{{/lineComment}}
{{/each}}

{{{content}}}

{{#lineComment this}}{{{config.endRegionMarker}}}{{/lineComment}}`
    this.appendStrategy = 'append'

    this.processors = ['./processors/handlebars-processor']
    this.appenders = ['./appenders/region-appender', './appenders/appender']

    this.scfFileName = '.scafflater'
    this.partialsFolderName = '_partials'
    this.hooksFolderName = '_hooks'
    this.helpersFolderName = '_helpers'

    this.cacheStorage = 'tempDir'
    this.cacheStorages = {
      tempDir: './storages/temp-dir-cache',
      homeDir: './storages/home-dir-cache',
    }

    this.source = 'github'
    this.sources = {
      github: './git-template-source',
    }

    this.github_baseUrlApi = 'https://api.github.com'
    this.github_baseUrl = 'https://github.com'
    this.github_username = null
    this.github_password = null
  }

  /** 
  * Merge the folder config
  * @param {string} folderPath Folder to load the config
  * @return {Promise<OptionsProvider>} The merged config
  */
  static mergeFolderConfig(folderPath, config) {
    return new Promise(async (resolve, reject) => {
      try {
        let result = { ...config }
        const scfFilePath = path.join(folderPath, config.scfFileName)
        if (await fsUtil.pathExists(scfFilePath)) {
          const info = await fsUtil.readJSON(scfFilePath)
          if (info.config) {
            result = { ...result, ...info.config }
          }
        }
        resolve(result)
      } catch (error) {
        reject(error)
      }
    })
  }

  /** 
  * Merge the file config
  * @param {string} folderPath File to load the config
  * @return {Promise<OptionsProvider>} The merged config
  */
  static extractConfigFromFileContent(filePath, config) {
    return new Promise(async (resolve, reject) => {
      try {
        const fileContent = await fsUtil.readFileContent(filePath)
        const result = await this.extractConfigFromString(fileContent, config)
        resolve(result)
      } catch (error) {
        reject(error)
      }
    })
  }

  static extractConfigFromString(str, config) {
    return new Promise(async (resolve, reject) => {
      try {
        const configRegex = new RegExp(`.*${config.optionMarker}\\s*(?<json>{.*}).*`, 'gi')
        const configs = str.matchAll(configRegex)
        let newConfig = {}

        const regionProvider = new RegionProvider(config)
        let regions = regionProvider.getRegions(str)

        for (const c of configs) {
          try {
            // Ignore configuration in regions
            if (regions.findIndex(r => r.contentStart <= c.index && r.contentEnd >= c.index) >= 0) {
              continue;
            }

            newConfig = { ...newConfig, ...JSON.parse(c.groups.json) }
          } catch (error) {
            reject(new Error(`Could not parse option '${c.groups.name}'`))
          }
        }

        resolve({
          ...config,
          ...newConfig
        })
      } catch (error) {
        reject(error)
      }
    })
  }

  static removeConfigFromString(str, config) {
    return new Promise(async (resolve, reject) => {
      try {
        const configRegex = new RegExp(`.*${config.optionMarker}\\s*(?<json>{.*}).*`, 'gi')
        resolve(str.replace(configRegex, ''))
      } catch (error) {
        reject(error)
      }
    })
  }
}

module.exports = OptionsProvider
