import { jest } from "@jest/globals";
import { createRequire } from "node:module";
import path from "node:path";

jest.unstable_mockModule("../fs-util", async () => {
  const ret = {
    saveFile: jest.fn(),
    readFileContent: jest.fn(),
    pathExists: jest.fn(),
    getDirTreeSync: jest.fn(),
    loadScriptsAsObjects: jest.fn(),
    listFilesByExtensionDeeply: jest.fn(),
    stat: jest.fn(),
    require: (jsPath) => {
      try {
        const p = path.resolve(import.meta.url);
        const require = createRequire(p);

        return require(jsPath);
      } catch (error) {
        if (error.code === "ERR_REQUIRE_ESM") {
          return import(jsPath);
        }
        throw error;
      }
    },
  };

  return {
    ...ret,
    default: ret,
  };
});

jest.unstable_mockModule("isbinaryfile", () => {
  return {
    ...jest.requireActual("isbinaryfile"),
    isBinaryFile: jest.fn(),
  };
});

jest.unstable_mockModule("glob", () => {
  return {
    glob: jest.fn(),
  };
});

const fsUtil = await import("../fs-util");
const Generator = (await import("./index")).default;
const { glob } = await import("glob");
const ScafflaterOptions = (await import("../options")).default;
const { isBinaryFile } = await import("isbinaryfile");

describe("Generator Tests", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  test("Render a simple file", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        config: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions({ annotate: true }),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });

    fsUtil.readFileContent.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return "existing content";

      return "{{parameters.test}}";
    });
    fsUtil.pathExists.mockImplementation((path) => {
      if (
        path.startsWith(ctx.targetPath) ||
        path.includes("hbs-builtin-helpers")
      )
        return true;
    });
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue(["lineComment.js"]);
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.stat.mockResolvedValue({ isFile: () => true });
    isBinaryFile.mockResolvedValue(false);
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(1);
    expect(fsUtil.saveFile.mock.calls[0][0]).toBe("/target/path/test.txt");
    expect(fsUtil.saveFile.mock.calls[0][1]).toBe(`existing content

# @scf-region
# This code was generated by scafflater
# @template test-template (v0.0.1)
# @partial _init
# @test a sample test

a sample test

# @end-scf-region`);
  });

  test("Does not change an existing file when appendStrategy equals 'ignore'", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        config: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions({
        annotate: false,
        appendStrategy: "ignore",
      }),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });
    fsUtil.readFileContent.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return "existing content";

      return "{{parameters.test}}";
    });
    fsUtil.pathExists.mockImplementation((path) => {
      if (
        path.startsWith(ctx.targetPath) ||
        path.includes("hbs-builtin-helpers")
      )
        return true;
    });
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue(["lineComment.js"]);
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(0);
  });

  test("Does not change an existing file when appendStrategy equals 'appendIfExists'", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        config: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions({
        annotate: false,
        appendStrategy: "appendIfExists",
      }),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });
    fsUtil.readFileContent.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return "existing content";

      return "{{parameters.test}}";
    });
    fsUtil.pathExists.mockImplementation((path) => {
      if (
        path.startsWith(ctx.targetPath) ||
        path.includes("hbs-builtin-helpers")
      )
        return false;
    });
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue(["lineComment.js"]);
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(0);
  });

  test("Annotate masked parameters", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        config: {
          lineCommentTemplate: "# {{comment}}",
        },
        parameters: [
          {
            name: "password",
            mask: true,
          },
        ],
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
        parameters: [
          {
            name: "otherPassword",
            mask: true,
          },
        ],
      },
      targetPath: "/target/path",
      parameters: {
        test: "a sample test",
        password: "password",
        otherPassword: "other-password",
      },
      options: new ScafflaterOptions({ annotate: true }),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });

    fsUtil.readFileContent.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return "existing content";

      return "{{parameters.test}}";
    });
    fsUtil.pathExists.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return true;
    });
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(1);
    expect(fsUtil.saveFile.mock.calls[0][0]).toBe("/target/path/test.txt");
    expect(fsUtil.saveFile.mock.calls[0][1]).toBe(`existing content

# @scf-region
# This code was generated by scafflater
# @template test-template (v0.0.1)
# @partial _init
# @test a sample test
# @password ******
# @otherPassword ******

a sample test

# @end-scf-region`);
  });

  test("Does not render an ignored file", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        options: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions(),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);
    fsUtil.readFileContent.mockImplementation((path) => {
      return `
      # @scf-option {"ignore":true}
      
      the file content
      `;
    });
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(0);
  });

  test("Does not render an empty file name config", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        options: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions(),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);
    fsUtil.readFileContent.mockImplementation((path) => {
      return `
      # @scf-option {"targetName":""}
      
      the file content
      `;
    });
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(0);
  });

  test("Save the file with name config", async () => {
    // ARRANGE
    const ctx = {
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
        options: {
          lineCommentTemplate: "# {{comment}}",
        },
      },
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: { test: "a sample test" },
      options: new ScafflaterOptions(),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "just/a/sample/test.txt",
      name: "test.txt",
      size: 100,
      type: "file",
      extension: ".txt",
    });
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);
    fsUtil.readFileContent.mockImplementation((path) => {
      return `
      # @scf-option {"targetName":"other-name.txt"}
      
      the file content
      `;
    });
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(1);
    expect(fsUtil.saveFile.mock.calls[0][0]).toBe(
      "/target/path/other-name.txt",
    );
  });

  test("Render parameters in the folder and file paths", async () => {
    // ARRANGE
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "the-partial-folder", // must be ignored
      name: "the-partial-folder",
      size: 200,
      type: "directory",
      children: [
        {
          path: "{{parameters.folderName}}",
          name: "{{parameters.folderName}}",
          size: 200,
          type: "directory",
          children: [
            {
              path: "{{parameters.folderName}}/{{parameters.fileName}}.txt",
              name: "{{parameters.fileName}}.txt",
              size: 100,
              type: "file",
              extension: ".txt",
            },
          ],
        },
      ],
    });
    fsUtil.readFileContent.mockReturnValue("{{parameters.test}}");
    const ctx = {
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: {
        test: "a sample test",
        folderName: "folder-name",
        fileName: "file-name",
      },
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
      },
      options: new ScafflaterOptions({ annotate: false }),
      helpersPath: "./the-hbs-helpers",
    };
    fsUtil.pathExists.mockImplementation((path) => {
      if (path.startsWith(ctx.targetPath)) return false;
    });
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);

    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(1);
    expect(fsUtil.saveFile.mock.calls[0][0]).toBe(
      "/target/path/folder-name/file-name.txt",
    );
    expect(fsUtil.saveFile.mock.calls[0][1]).toBe("a sample test");
  });

  test("Does not render empty paths", async () => {
    // ARRANGE
    fsUtil.getDirTreeSync.mockReturnValue({
      path: "/container/folder",
      name: "folder",
      size: 200,
      type: "directory",
      children: [
        {
          path: "/container/folder/{{parameters.folderName}}",
          name: "{{parameters.folderName}}",
          size: 200,
          type: "directory",
          children: [
            {
              path: "/container/folder/{{parameters.folderName}}/{{parameters.fileName}}.txt",
              name: "{{parameters.fileName}}.txt",
              size: 100,
              type: "file",
              extension: ".txt",
            },
            {
              path: "/container/folder/{{parameters.folderName}}/{{#if parameters.shouldRenderFile}}{{parameters.fileName}}.txt{{/if}}",
              name: "{{#if parameters.shouldRenderFile}}{{parameters.fileName}}.txt{{/if}}",
              size: 100,
              type: "file",
              extension: ".txt",
            },
            {
              path: "/container/folder/{{parameters.folderName}}/{{#if parameters.shouldRenderFolder}}another-folder{{/if}}",
              name: "{{#if parameters.shouldRenderFolder}}another-folder{{/if}}",
              size: 200,
              type: "directory",
              children: [
                {
                  path: "{{parameters.folderName}}/{{#if parameters.shouldRenderFolder}}another-folder{{/if}}/file.txt",
                  name: "file.txt",
                  size: 100,
                  type: "file",
                  extension: ".txt",
                },
              ],
            },
          ],
        },
      ],
    });
    fsUtil.readFileContent.mockReturnValue("{{parameters.test}}");
    fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
    fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);
    const ctx = {
      originPath: "/source/path",
      partial: {
        name: "_init",
        type: "init",
      },
      targetPath: "/target/path",
      parameters: {
        test: "a sample test",
        folderName: "folder-name",
        fileName: "file-name",
        shouldRenderFolder: false,
        shouldRenderFile: false,
      },
      templatePath: "/template/path",
      template: {
        name: "test-template",
        type: "template",
        version: "0.0.1",
      },
      options: new ScafflaterOptions({ annotate: false }),
      helpersPath: "./the-hbs-helpers",
    };
    const generator = new Generator(ctx);

    // ACT
    await generator.generate();

    // ASSERT
    expect(fsUtil.saveFile.mock.calls.length).toBe(1);
    expect(fsUtil.saveFile.mock.calls[0][0]).toBe(
      "/target/path/folder-name/file-name.txt",
    );
    expect(fsUtil.saveFile.mock.calls[0][1]).toBe("a sample test");
  });
});

test("Strip config", async () => {
  // ARRANGE
  fsUtil.getDirTreeSync.mockReturnValue({
    path: "the-partial-folder", // must be ignored
    name: "the-partial-folder",
    size: 200,
    type: "directory",
    children: [
      {
        path: "{{parameters.folderName}}",
        name: "{{parameters.folderName}}",
        size: 200,
        type: "directory",
        children: [
          {
            path: "{{parameters.folderName}}/{{parameters.fileName}}.xml",
            name: "{{parameters.fileName}}.xml",
            size: 100,
            type: "file",
            extension: ".txt",
          },
        ],
      },
    ],
  });
  fsUtil.readFileContent.mockReturnValue(
    `# @scf-option { "option": "option-value" }
# @scf-option { "option2": "option2-value" }
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<test>
    <prop>{{parameters.test}}</prop>
</test>`,
  );
  const ctx = {
    mode: "debug",
    originPath: "/source/path",
    partial: {
      name: "_init",
      type: "init",
    },
    targetPath: "/target/path",
    parameters: {
      test: "a sample test",
      folderName: "folder-name",
      fileName: "file-name",
    },
    templatePath: "/template/path",
    template: {
      name: "test-template",
      type: "template",
      version: "0.0.1",
    },
    options: new ScafflaterOptions({ annotate: false }),
    helpersPath: "./the-hbs-helpers",
  };
  fsUtil.pathExists.mockImplementation((path) => {
    if (path.startsWith(ctx.targetPath)) return false;
  });
  fsUtil.loadScriptsAsObjects.mockResolvedValue([]);
  fsUtil.listFilesByExtensionDeeply.mockResolvedValue([]);

  const generator = new Generator(ctx);

  // ACT
  await generator.generate();

  // ASSERT
  expect(fsUtil.saveFile.mock.calls.length).toBe(1);
  expect(fsUtil.saveFile.mock.calls[0][0]).toBe(
    "/target/path/folder-name/file-name.xml",
  );
  expect(fsUtil.saveFile.mock.calls[0][1])
    .toBe(`<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<test>
    <prop>a sample test</prop>
</test>
`);
});

describe("Resolve Target Name", () => {
  afterEach(() => {
    jest.clearAllMocks();
    jest.restoreAllMocks();
  });

  test("Receive a glob pattern. Should use it to resolve", async () => {
    // ARRANGE
    glob.mockResolvedValue([]);
    const generator = new Generator({
      targetPath: ".",
      templatePath: ".",
      options: new ScafflaterOptions(),
    });

    // ACT
    await generator.resolveTargetNames("glob</some/glob/pattern>", {});

    // ASSERT
    expect(glob).toHaveBeenCalledWith("/some/glob/pattern", expect.anything());
  });

  test("Receive a glob pattern with handlebars. Should render and use it to resolve", async () => {
    // ARRANGE
    glob.mockResolvedValue([]);
    const generator = new Generator({
      targetPath: ".",
      templatePath: ".",
      options: new ScafflaterOptions(),
    });

    // ACT
    await generator.resolveTargetNames(
      "glob</some/{{parameters.name}}/pattern>",
      { parameters: { name: "my-name" } },
    );

    // ASSERT
    expect(glob).toHaveBeenCalledWith(
      "/some/my-name/pattern",
      expect.anything(),
    );
  });

  test("Receive a each. Should use it to resolve", async () => {
    // ARRANGE
    glob.mockResolvedValue([]);
    const generator = new Generator({
      targetPath: ".",
      templatePath: ".",
      options: new ScafflaterOptions(),
    });

    // ACT
    const targetPaths = await generator.resolveTargetNames(
      "each<folder/file1,folder/file2>",
      {},
    );

    // ASSERT
    expect(targetPaths.length).toBe(2);
    expect(targetPaths[0]).toBe("folder/file1");
    expect(targetPaths[1]).toBe("folder/file2");
  });

  test("Receive a each with handlebars. Should render and use it to resolve", async () => {
    // ARRANGE
    glob.mockResolvedValue([]);
    const generator = new Generator({
      targetPath: ".",
      templatePath: ".",
      options: new ScafflaterOptions(),
    });

    // ACT
    const targetPaths = await generator.resolveTargetNames(
      "each<{{#each parameters.files}}{{this}},{{/each}}>",
      {
        parameters: {
          name: "my-name",
          files: ["folder/file1", "folder/file2"],
        },
      },
    );

    // ASSERT
    expect(targetPaths.length).toBe(2);
    expect(targetPaths[0]).toBe("folder/file1");
    expect(targetPaths[1]).toBe("folder/file2");
  });
});
